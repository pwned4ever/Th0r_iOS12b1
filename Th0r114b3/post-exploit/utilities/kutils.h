#ifndef kutils_h
#define kutils_h
#include "common.h"
#include <mach/mach.h>
#include "IOKit.h"

#define SETOFFSET(offset, val) (offs.offset = val)
#define GETOFFSET(offset) offs.offset

typedef struct {
    kptr_t trustcache;
    kptr_t OSBoolean_True;
    kptr_t osunserializexml;
    kptr_t smalloc;
    kptr_t add_x0_x0_0x40_ret;
    kptr_t zone_map_ref;
    kptr_t vfs_context_current;
    kptr_t vnode_lookup;
    kptr_t vnode_put;
    kptr_t kernel_task;
    kptr_t shenanigans;
    kptr_t lck_mtx_lock;
    kptr_t lck_mtx_unlock;
    kptr_t apfs_jhash_getvnode;
    kptr_t vnode_get_snapshot;
    kptr_t fs_lookup_snapshot_metadata_by_name_and_return_name;
    kptr_t extension_create_file;
    kptr_t extension_add;
    kptr_t extension_release;
    kptr_t pmap_load_trust_cache;
} offsets_t12;

extern offsets_t12 offs;
//extern uint64_t kernel_base;
//extern uint64_t kernel_slide;
extern uint64_t g_kern_base;

extern bool found_offsets;


extern uint64_t cached_task_self_addr;

uint64_t task_self_addr(void);
uint64_t ipc_space_kernel(void);
uint64_t find_kernel_base(void);

mach_port_t fake_host_priv(void);

size_t kread(uint64_t where, void *p, size_t size);
size_t kwrite(uint64_t where, const void *p, size_t size);
uint64_t kalloc(vm_size_t size);
uint64_t kalloc_wired(uint64_t size);
void kfree(mach_vm_address_t address, vm_size_t size);
uint64_t zm_fix_addr(uint64_t addr);
void set_csblob(uint64_t proc);
uint32_t find_pid_of_proc(const char *proc_name);
uint64_t get_proc_struct_for_pid(pid_t proc_pid);
uint64_t get_address_of_port(pid_t pid, mach_port_t port);

#endif /* kutils_h */
