//
//  electra.c
//  electra1131
//
//  Created by CoolStar on 6/6/18.
//  Copyright Â© 2018 CoolStar. All rights reserved.
//
#import <sys/stat.h>
#import <sys/utsname.h>
#import <dlfcn.h>
#include <assert.h>
#include <mach/mach.h>
#include <stdlib.h>
#include <unistd.h>
#include "electra.h"
#include "kutils.h"
#include "patchfinder64og.h"
//#include "../headers/QiLin.h"
#include "kexecute.h"
#include "codesign.h"
#include "offsetof.h"
#include "remap_tfp_set_hsp.h"
#include "unlocknvram.h"
#include "apfs_util.h"
#include "rootfs_remountog.h"
#include "electra_objc.h"
#include "bootstrap.h"
#include "file_utils.h"
#include "utils.h"
#include "nonce.h"
#include "unliberios.h"
#include "removePotentialJailbreak.h"
#include "detectConflictJailbreak.h"
#include "debug.h"
#include "amfi_utils.h"
#include "kernel_slide.h"
#include "parameters.h"
#include "kernel_memory.h"
#include "offsets.h"
#include "../headers/ipc_port.h"
#include "../headers/snappy.h"
#include "utilities/KernelMemory.h"
#include "../headers/kernelSymbolFinder.h"
#include "../headers/jelbrekLib.h"

#include "../exploit/vouch_4ya/kernel_memory.h"
#include "../exploit/v1ntex_sploit/v1ntex_exploit.h"
#include "../exploit/vouch_4ya/voucher_swap.h"
#include "../exploit/vouch_4ya/kernel_slide.h"
#include "utilities/KernelUtilities.h"
//#include "../exploit/mach_swap_ibsparks/mach_swap1.h"
#include "utilities/KernelUtilities.h"
#include "utilities/exploit_additions.h"

#define uicache "/electra/uicache"
#define killall "/electra/killall"


#define error(a...) \
do {            \
LOG(a);     \
LOG("");    \
} while (0)
#define assure(a)           \
do {                    \
if ((a) == 0) {     \
err = __LINE__; \
goto error;     \
}                   \
} while (0)
#define reterror(a...)  \
{                   \
error(a);       \
err = __LINE__; \
goto error;     \
}
#define doassure(cond, code) \
do {                     \
if (!(cond)) {       \
(code);          \
assure(cond);    \
}                    \
} while (0)


#define STATUS(msg, btnenbld, tbenbld) do { \
LOG("STATUS: %@", msg); \
dispatch_async(dispatch_get_main_queue(), ^{ \
[UIView performWithoutAnimation:^{ \
[[[JailbreakViewController sharedController] goButton] setEnabled:btnenbld]; \
[[[[JailbreakViewController sharedController] tabBarController] tabBar] setUserInteractionEnabled:tbenbld]; \
[[[JailbreakViewController sharedController] goButton] setTitle:msg forState: btnenbld ? UIControlStateNormal : UIControlStateDisabled]; \
[[[JailbreakViewController sharedController] goButton] layoutIfNeeded]; \
}]; \
}); \
} while (false)






#define TF_PLATFORM 0x00000400
#define ISADDR(val)            (val != 0 && val != HUGE_VAL && val != -HUGE_VAL)
#define ADDRSTRING(val)        [NSString stringWithFormat:@ADDR, val]
#define VROOT 0x000001 /* root of its file system */
#define VSYSTEM 0x000004 /* vnode being used by kernel */

kptr_t fromViewCkernel_base;
mach_port_t tfpzero = MACH_PORT_NULL;

bool acknowledgeSnapshotWarning = false;

void snapshotWarningRead(void){
    acknowledgeSnapshotWarning = true;
}

#define failIf(condition, message, ...) if (condition) {\
printf(message);\
goto end;\
}
#define maxVersion(v)  ([[[UIDevice currentDevice] systemVersion] compare:@v options:NSNumericSearch] != NSOrderedDescending)

uint64_t sharekernbaseVS;
uint64_t vkern_ucreds;
uint64_t vself_ucreds;
uint64_t newkern_ucredMS;
uint64_t newself_ucredMS;

int start_Th0r(mach_port_t tipsyPIEfp0, bool enable_tweaks){

    runningpatches();
    int err = ERR_NOERR;

    if (tipsyPIEfp0 == MACH_PORT_NULL) {
        return ERR_TFP0;
    }
    tfpzero = tipsyPIEfp0;
   
    printf("[*] Start kernel read write and patching launchd amfid gaining trust cache and mounting with snapshot rename and remove\n");
    
    if (kCFCoreFoundationVersionNumber >= 1535.12) {
        printf("offsets selected for iOS 12.0 or above\n");

        uint64_t kernel_base;
        kptr_t mynewbaseMachS;
        if (sharekernbaseVS != 22 && sharekernbaseVS != 0) {
            kernel_base = sharekernbaseVS;
        }else if (mynewvouchSbase != 22 && mynewvouchSbase != 0) {
            printf("mynewbase is 0x%llx\n",mynewvouchSbase);
            printf("kernel base from mynewvouchSbase: 0x%016llx\n", mynewvouchSbase);
            kernel_base = mynewvouchSbase;
        }else if (fromViewCkernel_base !=22 && fromViewCkernel_base != 0){
            printf("[i] sharekernbaseVS: 0x%llx\n", sharekernbaseVS);
            printf("[i] fromViewCkernel_base: 0x%llx\n", fromViewCkernel_base);
            kernel_base = fromViewCkernel_base;
        }else{
            kernel_base = find_kernel_base();
        }printf("[i] Kernel base: 0x%llx\n", kernel_base);
        init_kernel(kernel_base, NULL);//Loads kernel into the patch finder, which just fetches the kernel memory for patchfinder use
        uint64_t slide = kernel_base - 0xFFFFFFF007004000;// Get the slide
        printf("slide: 0x%016llx\n", slide);
        
        init_kexecute();
        
        uint64_t selfproc;
        uint64_t our_procJelbrek = VSourproc;
        printf("our_procJelbrek is 0x%llx\n", our_procJelbrek);
        uint32_t our_pid = getpid();
        printf("our_pid is %d\n", our_pid);
        uint64_t our_proc =get_proc_struct_for_pid(our_pid);
        

        init_with_kbase(tfp0, kernel_base);

        printf("our_proc is 0x%llx\n", our_proc);
        uint64_t launchd_proc = (get_proc_struct_for_pid(1));
        printf("launchd_proc is 0x%llx\n", launchd_proc);
        uint64_t kern_proc = get_proc_struct_for_pid(0);
        printf("kern_proc is 0x%llx\n", kern_proc);
        uint32_t amfid_pid = pid_of_procName("amfid");
        uint64_t amfid_proc = get_proc_struct_for_pid(amfid_pid);
        printf("amfid_pid is %d\n", amfid_pid);
        printf("amfid_proc is 0x%llx\n", amfid_proc);
        uint32_t cfprefsd_pid = pid_of_procName("cfprefsd");
        printf("cfprefsd_pid is %d\n", cfprefsd_pid);
        //init_jelbrek(tfp0);


        if (!our_proc || !launchd_proc || !kern_proc || !amfid_proc) {
            err = ERR_JAILBREAK;
            goto out;
        }
        
        printf("our proc is at 0x%016llx\n", our_proc);
        printf("launchd proc is at 0x%016llx\n", launchd_proc);
        printf("kern proc is at 0x%016llx\n", kern_proc);
        printf("amfid proc is at 0x%016llx\n", amfid_proc);
        
        
        printf("setcsflags(our_pid) returned:   %d\n", setcsflags(our_pid));
        
        printf("setcsflags launchd returned:    %d\n",  setcsflags(1));

        printf("setcsflags amfid proc returned: %d\n",  setcsflags(amfid_pid));

       /* uint32_t csflags;
        //0x78
        csflags = rk32(our_proc + offsetof_p_csflags);
        
        csflags = (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD | CS_KILL);
        printf("csflags :0x%x\n", csflags);
        wk32(our_proc + offsetof_p_csflags, csflags);
        */
        
        //set_csblob(our_proc);
       
        /*csflags = rk32(launchd_proc + offsetof_p_csflags);
        wk32(launchd_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
        
        csflags = rk32(amfid_proc + offsetof_p_csflags);
        wk32(amfid_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
        */
        
        
        if (find_pid_of_proc("jailbreakd")) {
            err = ERR_ALREADY_JAILBROKEN;
            goto out;
        }
      /*
        // Properly copy the kernel's credentials so setuid(0) doesn't crash
        */
        uint64_t copyout = Find_copyout();
        printf("copyout : 0x%llx\n", copyout);
        uint64_t bcopy = Find_bcopy();
        printf("bcopy : 0x%llx\n", bcopy);
        uint64_t bzero = Find_bzero();
        printf("bzero : 0x%llx\n", bzero);

        uint64_t kern_ucred = 0;
        //kexecute(copyout, kern_proc+OFFSET(proc, p_ucred), (uint64_t)&kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
        printf("kern_ucred : 0x%llx\n", kern_ucred);
        
    
        uint64_t self_ucred = 0;
        //kexecute(copyout, our_proc+OFFSET(proc, p_ucred), (uint64_t)&self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
        printf("self_ucred : 0x%llx\n", self_ucred);
        
        //kexecute(bcopy, kern_ucred + 0x78, self_ucred + 0x78, sizeof(uint64_t), 0, 0, 0, 0);
        //kexecute(bzero, self_ucred + 0x18, 12, 0, 0, 0, 0, 0);
        
        sleep(1);
        
        uint64_t selfproc1 = kernel_read64(current_task + OFFSET(task, bsd_info));
        printf("[*] selfproc?: 0x%llx\n", selfproc1);
        uint64_t ucred = kernel_read64(selfproc1 + OFFSET(proc, p_ucred));
        printf("[*] ucred?: 0x%llx\n", ucred);
        //new_self_ucreds_VS =ucred;
        uint64_t cr_label = kernel_read64(ucred + 0x78);
        printf("[*] cr_label?: 0x%llx\n", cr_label);
        kernel_write64(cr_label + 0x10, 0);
        
        
       
        rootify(getpid());
        unsandbox(getpid());
        setuid(0);
        if (getuid()) {
            err = ERR_JAILBREAK;
            goto out;
        }
        printf("our uid is %d\n", getuid());
        // Test writing to file
        {
            FILE *f = fopen("/var/mobile/test.txt", "w");
            if (f == 0) {
                printf("failed to write test file");
            } else {
                printf("wrote test file: %p\n", f);
            }
            
            unlink("/var/mobile/test.txt");
        }
        if (!file_exists("/var/mobile/Media/th0rkcache/kernelcache")) {
            int rv2 = mkdir("/var/mobile/Media/th0rkcache", 0777);

            printf("Made directory for kerenlcache in /var/mobile/Media/th0rkcache: %d\n", rv2);
            sleep(1);
        }
        if (!file_exists("/var/mobile/Media/th0rkcache/kernelcache")) {
            int rv2 = cp( "/var/mobile/Media/th0rkcache/kernelcache", "/System/Library/Caches/com.apple.kernelcaches/kernelcache");
            printf("wrote kernelcache file to /var/mobile/Media/th0rkcache/: %d\n", rv2);
            sleep(1);
        }
        //init_jelbrek(tfpzero);
        setcsflags(getpid()); // set some csflags
        platformize(getpid()); // set TF_PLATFORM
        
        //---- host special port 4 ----//
        
        failIf(setHSP4(), "[-] Failed to set tfp0 as hsp4!");
        PatchHostPriv(mach_host_self());
        
        UnlockNVRAM();
        sleep(1);
        printf("Mounted volumes:\n");
        printf("\n");
        
        int forkAndRunMount = fork();
        if (forkAndRunMount > 0){
            waitpid(forkAndRunMount, NULL, 0);
        } else if (forkAndRunMount == 0){
            const char *args_mount[] = {"mount", NULL};
            execv("/sbin/mount", (char **)&args_mount);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        
        int ret;
        
        // Only set a generator if one is not already set or if the user has specified one
        const char *currentgen = getgen();
        if (!currentgen || userGenerator()) {
            const char *gen = genToSet();
            // Only actually set the generator if it is not already set
            if (!currentgen || strcasecmp(currentgen, gen) != 0) {
                //printf("Setting generator to %s\n", gen);
                ret = setgen(gen);
                //printf("ret: %d\n", ret);
            } else {
                //printf("Requested generator already set: %s\n", gen);
            }
        }
        
        int forkAndRunNVRAM = fork();
        if (forkAndRunNVRAM > 0){
            waitpid(forkAndRunNVRAM, NULL, 0);
        } else if (forkAndRunNVRAM == 0){
            const char *args_nvram[] = {"nvram", "-p", NULL};
            execv("/usr/sbin/nvram", (char **)&args_nvram);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        LockNVRAM();
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        printf("APFS Snapshots: \n");
        printf("=========\n");
        int rootfd = open("/", O_RDONLY);
        printf("rootfd  =%d\n",rootfd);
        int snapshot_success = list_snapshots("/");
        printf("=========\n");
        
        ret = remountRootAsRW(slide, kern_proc, our_proc, snapshot_success);
        
        if (ret != 0) {
            err = ERR_ROOTFS_REMOUNT;
            goto out;
        }
        /*
        const char  **snapshot_success = list_snapshots("/");//copySystemSnapshot();//snapshot_list(rootfd);//
        printf("=========\n");
        int rootfd2 = open("/", O_RDONLY);
        printf("rootfd2  =%d\n",rootfd2);
        printf("our uid ? :%d\n", getuid());

        //find_symbol("/",TRUE);
        //find_symbol("_vnode_mount",TRUE);

        ret = remountRootAsRW(slide, kern_proc, our_proc, snapshot_success);//remountRootFS();//
       

        */
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
       /* if (ret != 0) {
            err = ERR_ROOTFS_REMOUNT;
            goto out;
        }
        
        */
        printf("Remounting RootFS...\n");
        copy_basebinaries();//copy_rootless_style_basebinaries();//
        
        forkAndRunMount = fork();
        if (forkAndRunMount > 0){
            waitpid(forkAndRunMount, NULL, 0);
        } else if (forkAndRunMount == 0){
            const char *args_mount[] = {"mount", NULL};
            execv("/sbin/mount", (char **)&args_mount);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        
        //dumpContentsOfDir("/");
        dumpContentsOfDir("/electra");
        
#define BinaryLocation "/electra/inject_criticald"
        
        int rv;
        pid_t pd;
        
        //launch("/electra/inject_criticald",NULL,NULL,NULL,NULL,NULL,NULL,NULL);
       //
        int rvtify = rootify(amfid_pid);
        printf("rootify amfid? :%d", rvtify);
        //patchAMFID();

        platformize(amfid_pid);
        platformize(getpid());
        platformize(1);
        int tfpamfi;
        mach_port_name_t nameoftfpamfi;
        
        nameoftfpamfi = task_for_pid_in_kernel(amfid_pid);
        printf("nameoftfpamfi amfid? :%d", nameoftfpamfi);
        task_for_pid(nameoftfpamfi, amfid_pid, &nameoftfpamfi);
        
        inject_dylib(nameoftfpamfi, "/electra/amfid_payload.dylib");
        inject_dylib(amfid_pid, "/electra/amfid_payload.dylib");

        //platformize(BinaryLocation);
        const char* args_amfid[] = {BinaryLocation, itoa(amfid_pid), "/electra/amfid_payload.dylib", NULL};
        rv = posix_spawn(&pd, BinaryLocation, NULL, NULL, (char **)&args_amfid, NULL);
        waitpid(pd, NULL, 0);
        uint64_t tfpPD;
        tfpPD = taskStruct_of_pid(pd);

        inject_dylib(tfpPD, "/electra/amfid_payload.dylib");
        printf("tfpPD task port of pid? :%d", tfpamfi);

        //unlink("/.amfid_success");
        const char *args_helloworld[] = {"helloworld", NULL};
        rv = posix_spawn(&pd, "/electra/helloworld", NULL, NULL, (char **)&args_helloworld, NULL);
        waitpid(pd, NULL, 0);
        
        if (!file_exists("/.amfid_success")){
            printf("amfid injection fail!\n");
            return ERR_AMFID_PATCH;
        }
        unlink("/.amfid_success");
        /* */
        
        //
        
        /*unlink("/.amfid_success");
        const char *args_helloworld[] = {"helloworld", NULL};
        rv = posix_spawn(&pd, "/electra/helloworld", NULL, NULL, (char **)&args_helloworld, NULL);
        waitpid(pd, NULL, 0);
        
        if (!file_exists("/.amfid_success")){
            printf("amfid injection fail!\n");
            return ERR_AMFID_PATCH;
        }
        unlink("/.amfid_success");
        */
        //uint64_t kernel_base = find_kernel_base();

        //
        int donecheckingremove = 0;
        
        if (checkingJUSTremovecheck()==TRUE){
            
            int bootstrapped = open("/var/mobile/Media/.bootstrapped_electraRemover", O_RDONLY);
            printf("[*****] REMOVER working!\n");
            donecheckingremove = 1;
            if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                if (bootstrapped == -1) {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot == 1){
                        printf("Snapshot exists!\n");
                    } else if (snapshot == 0){
                        rename("/electra/createSnapshot", "/createSnapshot");
                        pid_t pd;
                        rmdir("/electra");
                        
                        rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                        waitpid(pd, NULL, 0);
                        
                        printf("APFS Snapshots: \n");
                        
                        printf("=========\n");
                        list_snapshots("/");
                        printf("=========\n");
                        
                        snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            err = ERR_SNAPSHOT;
                            goto out;
                        }
                        
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotNotice();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        
                        copy_basebinaries();
                    }
                } else {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        if (!file_exists("/.electra_no_snapshot")){
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotWarning();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                            close(rv);
                        }
                    }
                }
            }
            
            close(bootstrapped);
            
        }else {
            int bootstrapped = open("/.bootstrapped_Th0r", O_RDONLY);
            
            if (bootstrapped == -1) {
                if (checkLiberiOS() == true) {
                    removingLiberiOS();
                    removeLiberiOS();
                }
#if ELECTRADEBUG
#else /* !ELECTRADEBUG */
                if (detectConflictJailbreak()) {
                    err = ERR_CONFLICT;
                    goto out;
                }
#endif /* !ELECTRADEBUG */
                removePotentialJailbreak();
            }
            if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                if (bootstrapped == -1) {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot == 1){
                        printf("Snapshot exists!\n");
                    } else if (snapshot == 0){
                        rename("/electra/createSnapshot", "/createSnapshot");
                        pid_t pd;
                        rmdir("/electra");
                        
                        rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                        waitpid(pd, NULL, 0);
                        
                        printf("APFS Snapshots: \n");
                        
                        printf("=========\n");
                        list_snapshots("/");
                        printf("=========\n");
                        
                        snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            err = ERR_SNAPSHOT;
                            goto out;
                        }
                        
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotNotice();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        
                        copy_basebinaries();
                    }
                } else {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        if (!file_exists("/.electra_no_snapshot")){
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotWarning();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                            close(rv);
                        }
                    }
                }
            }
            close(bootstrapped);
        }
        printf("Running mount...\n");
        //rmounting();
        term_kexecute();
        //---- bootstrap ----//
        extract_bootstrap();

        if ( donecheckingremove == 1){
            printf("[*****]hello checking for remover easier!: %d \n", donecheckingremove);
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        }else {
            serverS();
            printf("Starting server...\n");
            start_jailbreakd(kernel_base);
            wait4jailbreakd();
            while (!file_exists("/var/run/jailbreakd.pid")){
                printf("Waiting for jailbreakd...\n");
                usleep(100000);//10 ms
            }
            
        }

        unlink("/electra/createSnapshot");
        unlink("/electra/rm");
        
        update_springboard_plist();
    
        if (donecheckingremove == 1){
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        }else {
            kill(cfprefsd_pid, SIGKILL);
        }
        term_kernel();
        if (donecheckingremove == 1){
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        }else {
            while (!file_exists("/electra/pspawn_payload.dylib")){
                usleep(100000);
            }
            char *wpspawn = "/electra/pspawn_payload.dylib";
            //launch(BinaryLocation,1,NULL,NULL,NULL,NULL,NULL,&wpspawn);
            run(""BinaryLocation" 1 /electra/pspawn_payload.dylib");

            if (enable_tweaks){
                startdwait();
                startDaemons();
                while (!file_exists("/electra/killall")){
                    usleep(100000);
                    printf("waiting on killall\n");
                    
                }
                while (!file_exists("/usr/bin/ldrestart")){
                    usleep(100000);
                    printf("waiting on ldrestart\n");
                    
                }
                //setuid(501);
                launch("/electra/killall SpringBoard",NULL,NULL,NULL,NULL,NULL,NULL,NULL);
                
                platformize(getpid());
                
                posix_spawnp(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "SpringBoard", NULL }, NULL);
                printf("ldrestart our uid ? :%d\n", getuid());
                //posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "SpringBoard", NULL }, NULL);
                //posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "backboardd", NULL }, NULL);
               /* int rv = chmod("/usr/bin/ldrestart", 04755);//ldrestart 06777
                printf("modded ? :%d", rv);
                
                posix_spawn(&pd, "/usr/bin/ldrestart", NULL, NULL, (char **)&(const char*[]){ "/usr/bin/ldrestart",NULL, NULL }, NULL);
                */
                waitpid(pd, NULL, 0);
                
            }
        }

        
        
        
        
        
        
     
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }else if (kCFCoreFoundationVersionNumber < 1535.12) {
        printf("kernel_base selected for iOS 11.0 - 11.4.1\n");
        uint64_t kernel_base = find_kernel_base();
        printf("[i] Kernel base: 0x%llx\n", kernel_base);
        
        init_kernel(kernel_base, NULL);//Loads kernel into the patch finder, which just fetches the kernel memory for patchfinder use
        
        uint64_t slide = kernel_base - 0xFFFFFFF007004000;// Get the slide
        printf("slide: 0x%016llx\n", slide);
        init_kexecute();
        
        uint32_t our_pid = getpid();
        printf("our_pid is %d\n", our_pid);
        uint64_t our_proc = get_proc_struct_for_pid(our_pid);
        printf("our_proc is %llx\n", our_proc);
        uint64_t launchd_proc = (get_proc_struct_for_pid(1));
        printf("launchd_proc is %llx\n", launchd_proc);
        uint64_t kern_proc = get_proc_struct_for_pid(0);
        printf("kern_proc is %llx\n", kern_proc);
        uint32_t amfid_pid = find_pid_of_proc("amfid");
        printf("amfid_pid is %d\n", amfid_pid);
        uint64_t amfid_proc = get_proc_struct_for_pid(amfid_pid);
        printf("amfid_proc is %llx\n", amfid_proc);
        uint32_t cfprefsd_pid = find_pid_of_proc("cfprefsd");
        printf("cfprefsd_pid is %d\n", cfprefsd_pid);
    end:
        if (!our_proc || !launchd_proc || !kern_proc || !amfid_proc) {
            err = ERR_JAILBREAK;
            goto out;
        }
        
        printf("our proc is at 0x%016llx\n", our_proc);
        printf("launchd proc is at 0x%016llx\n", launchd_proc);
        printf("kern proc is at 0x%016llx\n", kern_proc);
        printf("amfid proc is at 0x%016llx\n", amfid_proc);
        
        
        uint32_t csflags;
        
        csflags = rk32(our_proc + offsetof_p_csflags);
        csflags = (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD | CS_KILL);
        printf("csflags :0x%x\n", csflags);
        wk32(our_proc + offsetof_p_csflags, csflags);
        
        set_csblob(our_proc);
        
        csflags = rk32(launchd_proc + offsetof_p_csflags);
        wk32(launchd_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
        
        csflags = rk32(amfid_proc + offsetof_p_csflags);
        wk32(amfid_proc + offsetof_p_csflags, (csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW) & ~(CS_RESTRICT | CS_HARD));
        
        
        if (find_pid_of_proc("jailbreakd")) {
            err = ERR_ALREADY_JAILBROKEN;
            goto out;
        }
        
        // Properly copy the kernel's credentials so setuid(0) doesn't crash
        
        uint64_t copyout = find_copyout();
        uint64_t bcopy = find_bcopy();
        uint64_t bzero = find_bzero();

        uint64_t kern_ucred = 0;
        kexecute(copyout, kern_proc+offsetof_p_ucred, (uint64_t)&kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
        printf("copyout : 0x%llx\n", copyout);
        printf("bcopy : 0x%llx\n", bcopy);
        printf("bzero : 0x%llx\n", bzero);
        printf("kern_ucred : 0x%llx\n", kern_ucred);
        uint64_t new_self_ucreds_VS;

        uint64_t self_ucred = 0;
        /*if (new_self_ucreds_VS != 0) {
            self_ucred = new_self_ucreds_VS;
            //kexecute(copyout, our_proc+offsetof_p_ucred, (uint64_t)&self_ucred, sizeof(self_ucred), 0, 0, 0, 0);

        }
        else{
         */
        kexecute(copyout, our_proc+offsetof_p_ucred, (uint64_t)&self_ucred, sizeof(self_ucred), 0, 0, 0, 0);

       // }
        printf("self_ucred : 0x%llx\n", self_ucred);
        
        kexecute(bcopy, kern_ucred + 0x78, self_ucred + 0x78, sizeof(uint64_t), 0, 0, 0, 0);
        kexecute(bzero, self_ucred + 0x18, 12, 0, 0, 0, 0, 0);
        
        setuid(0);
        extern int whatsmyuid;
        whatsmyuid = getuid();
        if (whatsmyuid) {
            err = ERR_JAILBREAK;
            goto out;
        }

        printf("our uid is %d\n", whatsmyuid);
        myuidroot();
        // Test writing to file
        {
            FILE *f = fopen("/var/mobile/test.txt", "w");
            if (f == 0) {
                printf("failed to write test file");
            } else {
                printf("wrote test file: %p\n", f);
            }
            
            unlink("/var/mobile/test.txt");
        }
        mkdir("/var/mobile/Media/th0rkcache", 0777);
        
        int rv2 = cp( "/var/mobile/Media/th0rkcache/kernelcache", "/System/Library/Caches/com.apple.kernelcaches/kernelcache");
        printf("wrote kernelcache file: %d\n", rv2);
        init_jelbrek(tfpzero);
        initWithKernelCache("/var/mobile/Media/th0rkcache/kernelcache");
        settingsetHSP4();
        //---- host special port 4 ----//
        failIf(setHSP4(), "[-] Failed to set tfp0 as hsp4!");
        PatchHostPriv(mach_host_self());
        UnlockNVRAM();
        //remap_tfp0_set_hsp4(&tfpzero);
        //remountRootFS();
        
        printf("Mounted volumes:\n");
        printf("\n");
        
        int forkAndRunMount = fork();
        if (forkAndRunMount > 0){
            waitpid(forkAndRunMount, NULL, 0);
        } else if (forkAndRunMount == 0){
            const char *args_mount[] = {"mount", NULL};
            execv("/sbin/mount", (char **)&args_mount);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        
        int ret;
        
        // Only set a generator if one is not already set or if the user has specified one
        const char *currentgen = getgen();
        if (!currentgen || userGenerator()) {
            const char *gen = genToSet();
            // Only actually set the generator if it is not already set
            if (!currentgen || strcasecmp(currentgen, gen) != 0) {
                //printf("Setting generator to %s\n", gen);
                ret = setgen(gen);
                //printf("ret: %d\n", ret);
            } else {
                //printf("Requested generator already set: %s\n", gen);
            }
        }
        
        int forkAndRunNVRAM = fork();
        if (forkAndRunNVRAM > 0){
            waitpid(forkAndRunNVRAM, NULL, 0);
        } else if (forkAndRunNVRAM == 0){
            const char *args_nvram[] = {"nvram", "-p", NULL};
            execv("/usr/sbin/nvram", (char **)&args_nvram);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        LockNVRAM();
        //locknvram();
        printf("APFS Snapshots: \n");
        printf("=========\n");
        
        int snapshot_success = list_snapshots("/");
        printf("=========\n");
        
        ret = remountRootAsRW(slide, kern_proc, our_proc, snapshot_success);
        
        if (ret != 0) {
            err = ERR_ROOTFS_REMOUNT;
            goto out;
        }
        
        
        printf("Remounting RootFS...");
        copy_basebinaries();
        
        forkAndRunMount = fork();
        if (forkAndRunMount > 0){
            waitpid(forkAndRunMount, NULL, 0);
        } else if (forkAndRunMount == 0){
            const char *args_mount[] = {"mount", NULL};
            execv("/sbin/mount", (char **)&args_mount);
            printf("Child should never reach here!\n");
            exit(-1);
        } else {
            printf("Unable to fork!\n");
        }
        
        //dumpContentsOfDir("/");
        //dumpContentsOfDir("/electra");
        
#define BinaryLocation "/electra/inject_criticald"
        
        int rv;
        pid_t pd;
        
        const char* args_amfid[] = {BinaryLocation, itoa(amfid_pid), "/electra/amfid_payload.dylib", NULL};
        rv = posix_spawn(&pd, BinaryLocation, NULL, NULL, (char **)&args_amfid, NULL);
        waitpid(pd, NULL, 0);
        
        unlink("/.amfid_success");
        const char *args_helloworld[] = {"helloworld", NULL};
        rv = posix_spawn(&pd, "/electra/helloworld", NULL, NULL, (char **)&args_helloworld, NULL);
        waitpid(pd, NULL, 0);
        
       /* if (!file_exists("/.amfid_success")){
            printf("amfid injection fail!\n");
            return ERR_AMFID_PATCH;
        }
        */
        unlink("/.amfid_success");
        
            //
        int donecheckingremove = 0;

        if (checkingJUSTremovecheck()==TRUE){
            int bootstrapped = open("/var/mobile/Media/.bootstrapped_electraRemover", O_RDONLY);
            printf("[*****] REMOVER working!\n");
            donecheckingremove = 1;
            if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                if (bootstrapped == -1) {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot == 1){
                        printf("Snapshot exists!\n");
                    } else if (snapshot == 0){
                        rename("/electra/createSnapshot", "/createSnapshot");
                        pid_t pd;
                        rmdir("/electra");
                        
                        rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                        waitpid(pd, NULL, 0);
                        
                        printf("APFS Snapshots: \n");
                        
                        printf("=========\n");
                        list_snapshots("/");
                        printf("=========\n");
                        
                        snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            err = ERR_SNAPSHOT;
                            goto out;
                        }
                        
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotNotice();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        
                        copy_basebinaries();
                    }
                } else {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        if (!file_exists("/.electra_no_snapshot")){
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotWarning();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                            close(rv);
                        }
                    }
                }
            }
            
            close(bootstrapped);
            
        }else {
            int bootstrapped = open("/.bootstrapped_Th0r", O_RDONLY);
            
            if (bootstrapped == -1) {
                if (checkLiberiOS() == true) {
                    removingLiberiOS();
                    removeLiberiOS();
                }
#if ELECTRADEBUG
#else /* !ELECTRADEBUG */
                if (detectConflictJailbreak()) {
                    err = ERR_CONFLICT;
                    goto out;
                }
#endif /* !ELECTRADEBUG */
                removePotentialJailbreak();
            }
            if (snapshot_success == 0 && kCFCoreFoundationVersionNumber <= 1451.51){
                if (bootstrapped == -1) {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot == 1){
                        printf("Snapshot exists!\n");
                    } else if (snapshot == 0){
                        rename("/electra/createSnapshot", "/createSnapshot");
                        pid_t pd;
                        rmdir("/electra");
                        
                        rv = posix_spawn(&pd, "/createSnapshot", NULL, NULL, (char **)&(const char*[]){ "createSnapshot", NULL }, NULL);
                        waitpid(pd, NULL, 0);
                        
                        printf("APFS Snapshots: \n");
                        
                        printf("=========\n");
                        list_snapshots("/");
                        printf("=========\n");
                        
                        snapshot = check_snapshot("/", "electra-prejailbreak");
                        if (snapshot != 1){
                            err = ERR_SNAPSHOT;
                            goto out;
                        }
                        
                        acknowledgeSnapshotWarning = false;
                        displaySnapshotNotice();
                        while (!acknowledgeSnapshotWarning){
                            usleep(1000000);
                        }
                        
                        copy_basebinaries();
                    }
                } else {
                    int snapshot = check_snapshot("/", "electra-prejailbreak");
                    if (snapshot != 1){
                        if (!file_exists("/.electra_no_snapshot")){
                            acknowledgeSnapshotWarning = false;
                            displaySnapshotWarning();
                            while (!acknowledgeSnapshotWarning){
                                usleep(1000000);
                            }
                            int rv = open("/.electra_no_snapshot", O_RDWR|O_CREAT);
                            close(rv);
                        }
                    }
                }
            }
            close(bootstrapped);
        }
            
        printf("Running mount...\n");
        rmounting();
        term_kexecute();
        
        //---- bootstrap ----//
        extract_bootstrap();
        serverS();
        printf("Starting server...\n");
        if (donecheckingremove == 1){
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        }else {
            wait4jailbreakd();
            start_jailbreakd(kernel_base);
            while (!file_exists("/var/run/jailbreakd.pid")){
                printf("Waiting for jailbreakd...\n");
                usleep(100000);//10 ms
            }
        }
        unlink("/electra/createSnapshot");
        unlink("/electra/rm");
        update_springboard_plist();
        if (donecheckingremove == 1){
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
        }else {
            kill(cfprefsd_pid, SIGKILL);
        }

        sleep(1);
        term_kernel();
        term_jelbrek();
        if (donecheckingremove == 1){
            printf("[*****] FUCK REMOVER IS GETTING CLOSER!\n");
            removerdone();
            return err;
            
        }else {
            while (!file_exists("/electra/pspawn_payload.dylib")){
                usleep(100000);
            }
            run(""BinaryLocation" 1 /electra/pspawn_payload.dylib");
            if (enable_tweaks){
                startdwait();
                startDaemons();
                while (!file_exists("/electra/killall")){
                    usleep(100000);
                    printf("waiting on killall\n");

                }
                while (!file_exists("/usr/bin/ldrestart")){
                    usleep(100000);
                    printf("waiting on ldrestart\n");

                }
                //setuid(501);
                launchAsPlatform("/electra/killall SpringBoard",NULL,NULL,NULL,NULL,NULL,NULL,NULL);
                
                //platformize(getpid());
                

                launch("/electra/killall", "SpringBoard",NULL, NULL, NULL, NULL, NULL, NULL);
                launch("/electra/killall SpringBoard",NULL,NULL, NULL, NULL, NULL, NULL, NULL);
                printf("ldrestart our uid ? :%d\n", getuid());

                posix_spawnp(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "SpringBoard", NULL }, NULL);
                //posix_spawn(&pd, "/electra/killall", NULL, NULL, (char **)&(const char*[]){ "/electra/killall", "backboardd", NULL }, NULL);
               // posix_spawn(&pd, "/usr/bin/ldrestart", NULL, NULL, (char **)&(const char*[]){ "/usr/bin/ldrestart",NULL, NULL }, NULL);
                //waitpid(pd, NULL, 0);
                waitpid(pd, NULL, 0);
            }
        }
           return err;
    }
    return err;
out:
    term_jelbrek();
    term_kexecute();
    term_kernel();
    return err;
}
