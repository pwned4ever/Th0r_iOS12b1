








addr_t find_trustcache(void) {
    addr_t call1, call2, call3, call4, call5;
    addr_t func1, func2, func4;
    addr_t val;
    addr_t amfiUC_inTrustCache = find_strref("%s: only allowed process can check the trust cache", 1, 1); // Trying to find AppleMobileFileIntegrityUserClient::isCdhashInTrustCache
    amfiUC_inTrustCache -= kerndumpbase;
    call1 = step64_back(kernel, amfiUC_inTrustCache, 11*4, INSN_CALL);
    
    func1 = follow_call64(kernel, call1);
    
    call2 = step64(kernel, func1, 8*4, INSN_CALL);
    func2 = follow_call64(kernel, call2);
    
    call3 = step64(kernel, func2, 8*4, INSN_CALL);
    
    // We ignore the above call, as we are looking for the dynamic cache
    call4 = step64(kernel, call3+4, 8*4, INSN_CALL);
    func4 = follow_call64(kernel, call4);
    
    call5 = step64(kernel, func4, 12*4, INSN_CALL);
    
    val = calc64(kernel, call5, call5 + 6*4, 21);
    
    return val + kerndumpbase;
}

addr_t find_amficache(void) {
	addr_t call, func, bof, val;
	addr_t ref = find_strref("com.apple.MobileFileIntegrity", 1, 1);
	if (!ref) {
		return 0;
	}
	ref -= kerndumpbase;
	call = step64(kernel, ref, 32, INSN_CALL);
	if (!call) {
		return 0;
	}
	call = step64(kernel, call+4, 32, INSN_CALL);
	func = follow_call64(kernel, call);
	if (!func) {
		return 0;
	}
	bof = bof64(kernel, func - 256, func);
	if (!bof) {
		return 0;
	}
	val = calc64(kernel, bof, func, 9);
	if (!val) {
		return 0;
	}
	return val + kerndumpbase;
}

addr_t find_realhost(void) {
    uint64_t val = kerndumpbase;

    addr_t ref1 = find_strref("\"ipc_init: kmem_suballoc of ipc_kernel_copy_map failed\"", 1, 0);
    ref1 -= kerndumpbase;
    addr_t ref2 = find_strref("\"ipc_host_init\"", 1, 0);
    ref2 -= kerndumpbase;

    addr_t call = ref2;
    call = step64(kernel, call+4, 32, INSN_CALL); // panic
    call = step64(kernel, call+4, 32, INSN_CALL); // something about
    call = step64(kernel, call+4, 32, INSN_CALL); // allocing ports
    call = step64(kernel, call+4, 32, INSN_CALL); // _lck_mtx_lock

    call -= 4; // previous insn

    uint32_t mov_opcode = *(uint32_t*)(kernel+call);
    // must be mov x0, xm
    if ((mov_opcode & 0xAA0003E0) != 0xAA0003E0) {
        return 0;
    }
    uint8_t xm = (mov_opcode & 0x1F0000) >> 16;

    uint32_t *insn = (uint32_t*)(kernel+ref1);
    int i = 0;

    // adrp xX, #_realhost@PAGE
    for (i = 0; i != ref2 - ref1; ++i) {
        if ((insn[i] & xm) == xm && (insn[i] & 0x9F000000) == 0x90000000)
            break;
    }

    if (i == ref2 - ref1) {
        return 0;
    }

    // get pc
    val += ((uint8_t*)(insn + i) - kernel) & ~0xfff;

    // don't ask, I wrote this at 5am
    val += (insn[i]<<9 & 0x1ffffc000) | (insn[i]>>17 & 0x3000);

    // add xX, xX, #_realhost@PAGEOFF
    ++i;
    // xd == xX, xn == xX, SS == 00
    if ((insn[i]&0x1f) != xm || ((insn[i]>>5)&0x1f) != xm || ((insn[i]>>22)&3) != 0) {
        return 0;
    }

    val += (insn[i]>>10) & 0xfff;

    return val;
}

addr_t find_zone_map_ref(void) {
    // \"Nothing being freed to the zone_map. start = end = %p\\n\"
    uint64_t val = kerndumpbase;

    addr_t ref = find_strref("\"Nothing being freed to the zone_map. start = end = %p\\n\"", 1, 0);
    ref -= kerndumpbase;

    // skip add & adrp for panic str
    ref -= 8;

    // adrp xX, #_zone_map@PAGE
    ref = step64_back(kernel, ref, 30, INSN_ADRP);

    uint32_t *insn = (uint32_t*)(kernel+ref);
    // get pc
    val += ((uint8_t*)(insn) - kernel) & ~0xfff;
    uint8_t xm = *insn & 0x1f;

    // don't ask, I wrote this at 5am
    val += (*insn<<9 & 0x1ffffc000) | (*insn>>17 & 0x3000);

    // ldr x, [xX, #_zone_map@PAGEOFF]
    ++insn;
    if ((*insn & 0xF9C00000) != 0xF9400000) {
        return 0;
    }

    // xd == xX, xn == xX,
    if ((*insn&0x1f) != xm || ((*insn>>5)&0x1f) != xm) {
        return 0;
    }

    val += ((*insn >> 10) & 0xFFF) << 3;

    return val;
}

uint64_t find_zone_map(void) {
    uint64_t zone_map_kptr = find_zone_map_ref();
    uint64_t zone_map = rk64m(zone_map_kptr);
    return zone_map;
}
